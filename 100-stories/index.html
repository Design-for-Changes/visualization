<!doctype html>
<meta charset="utf-8" />
<style>
  html, body { height: 100%; margin: 0; }
  body { font-family: -apple-system, "Hiragino Sans", "Noto Sans CJK JP", sans-serif; }
  #ui-ribbon {
    position: fixed;
    top: 0; left: 0; right: 0;
    display: flex;
    flex-direction: column;
    gap: 10px;
    padding: 12px 12px 0;
    z-index: 30;
    pointer-events: none;
  }
  #ui-ribbon > * {
    pointer-events: auto;
  }
  #view-tabs {
    display: flex;
    gap: 12px;
    border-radius: 16px;
    background: rgba(255,255,255,0.95);
    border: 1px solid rgba(0,0,0,0.08);
    box-shadow: 0 2px 12px rgba(0,0,0,0.08);
    padding: 8px;
  }
  #view-tabs .tab-button {
    flex: 1 1 0;
    padding: 14px 18px;
    border: 1px solid transparent;
    border-radius: 12px;
    background: transparent;
    font-size: 18px;
    font-weight: 600;
    cursor: pointer;
    transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
  }
  #view-tabs .tab-button:hover {
    border-color: rgba(10,124,255,0.35);
    background: rgba(10,124,255,0.08);
  }
  #view-tabs .tab-button.active {
    background: #0a7cff;
    border-color: #0a7cff;
    color: #fff;
    box-shadow: 0 6px 16px rgba(10,124,255,0.25);
  }
  #category-toggle-row {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    padding: 0 4px 12px;
  }
  .category-toggle {
    flex: 1 1 160px;
    min-width: 140px;
    padding: 12px 14px;
    border-radius: 12px;
    border: 1px solid rgba(0,0,0,0.12);
    background: rgba(255,255,255,0.94);
    font-size: 16px;
    font-weight: 500;
    display: flex;
    align-items: center;
    gap: 10px;
    cursor: pointer;
    box-shadow: 0 1px 4px rgba(0,0,0,0.08);
    transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease, opacity 0.15s ease;
  }
  .category-toggle:hover {
    transform: translateY(-1px);
    box-shadow: 0 3px 10px rgba(0,0,0,0.1);
  }
  .category-toggle .swatch {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    border: 2px solid rgba(255,255,255,0.9);
    box-shadow: 0 0 0 1px rgba(0,0,0,0.12);
  }
  .category-toggle.inactive {
    opacity: 0.5;
    background: rgba(245,245,245,0.95);
    border-style: dashed;
  }
  svg { width: 100vw; height: 100vh; display: block; background: #fff; }
  #summary-view {
    display: none;
    width: 100vw;
    height: 100vh;
    overflow-y: auto;
    box-sizing: border-box;
    background: #fff;
    padding: 148px 22px 48px;
    font-size: 16px;
    line-height: 1.7;
  }
  #summary-view h2 {
    margin: 0 0 18px;
    font-size: 26px;
    letter-spacing: 0.03em;
  }
  #summary-view h3 {
    margin: 26px 0 10px;
    font-size: 20px;
  }
  #summary-view ol {
    margin: 0 0 12px 20px;
    padding: 0;
  }
  #summary-view li {
    margin-bottom: 6px;
  }
  #summary-category-tabs {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin: 12px 0 18px;
  }
  #summary-category-tabs .summary-tab {
    padding: 10px 16px;
    border-radius: 999px;
    border: 1px solid #ccd3dd;
    background: rgba(245,248,255,0.92);
    font-size: 16px;
    cursor: pointer;
    box-shadow: 0 1px 2px rgba(0,0,0,0.05);
  }
  #summary-category-tabs .summary-tab.active {
    background: #0a7cff;
    border-color: #0a7cff;
    color: #fff;
  }
  @media (max-width: 960px) {
    #view-tabs .tab-button {
      font-size: 17px;
      padding: 12px 16px;
    }
    .category-toggle {
      flex: 1 1 calc(50% - 10px);
    }
    #summary-view {
      padding: 138px 18px 40px;
      font-size: 15px;
    }
  }
  @media (max-width: 720px) {
    #ui-ribbon {
      gap: 12px;
      padding: 10px 10px 0;
    }
    #view-tabs {
      padding: 6px;
    }
    #view-tabs .tab-button {
      font-size: 18px;
      padding: 14px 10px;
    }
    #category-toggle-row {
      gap: 8px;
    }
    .category-toggle {
      flex: 1 1 100%;
      min-width: 0;
      font-size: 17px;
      padding: 14px;
    }
    svg {
      margin-top: 128px;
    }
    #summary-view {
      padding-top: 160px;
      font-size: 16px;
    }
  }
</style>

<div id="ui-ribbon">
  <div id="view-tabs">
    <button type="button" class="tab-button active" data-view="network">ネットワーク</button>
    <button type="button" class="tab-button" data-view="summary">単純集計</button>
  </div>
  <div id="category-toggle-row"></div>
</div>
<svg id="chart"></svg>
<div id="summary-view"></div>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script>
const svg = d3.select("#chart");
const svgNode = document.getElementById("chart");
const summaryViewEl = document.getElementById("summary-view");
const summaryContent = d3.select("#summary-view");
const tabButtons = Array.from(document.querySelectorAll("#view-tabs .tab-button"));
const categoryToggleRow = document.getElementById("category-toggle-row");
let currentView = "network";
const MARGIN = { top: 60, right: 10, bottom: 10, left: 10 };
let width = window.innerWidth, height = window.innerHeight;

tabButtons.forEach(btn => {
  btn.addEventListener("click", () => setView(btn.dataset.view));
});

const gPlot = svg.append("g").attr("class", "plot");

const tooltip = d3.select("body").append("div")
  .style("position", "absolute")
  .style("padding", "6px 10px")
  .style("background", "rgba(0,0,0,0.75)")
  .style("color", "white")
  .style("border-radius", "4px")
  .style("font-size", "12px")
  .style("pointer-events", "none")
  .style("opacity", 0);

let samples = [];
let categories = [];
let network = { nodes: [], edges: [] };
let activeCategories = null;
// let searchText = ""; // removed as per instructions

let x = d3.scaleLinear(), y = d3.scaleLinear();
let colorScale = d3.scaleOrdinal();
let rScale = d3.scaleSqrt();
let currentK = 1;
const sizeResponse = 1.0; // fixed value
let edgeWidthScale = d3.scaleSqrt();
let edgeOpacityScale = d3.scaleSqrt();
let selectedCategoryLabel = null;
let categorySampleMap = new Map();
let categoryByLabel = new Map();
let sampleById = new Map();
let summaryCategoryFilter = "all";

const zoom = d3.zoom()
  .scaleExtent([0.5, 12])
  .on("zoom", (event) => {
    currentK = event.transform.k;
    gPlot.attr("transform", event.transform);
    updateSizes(currentK);
    applyHighlights(false);
  });
svg.call(zoom);
svg.on("click.highlight", () => {
  setSelectedCategory(null);
});

function formatSampleId(v) {
  const n = +v;
  if (Number.isFinite(n)) {
    const adj = (n >= 1000 ? n - 1000 : n);
    return String(Math.max(0, Math.trunc(adj))).padStart(3, "0");
  }
  return v ?? "(idなし)";
}
function normalizeColumns(rows) {
  const trimmed = rows.map(r => {
    const o = {};
    for (const k of rows.columns) {
      const key = String(k).trim();
      o[key] = r[k];
    }
    return o;
  });
  trimmed.columns = rows.columns.map(c => String(c).trim());
  return trimmed;
}

function clamp(value, min, max) {
  return Math.min(max, Math.max(min, value));
}

function getAllCategoryNames() {
  return Array.from(new Set(categories.map(d => d.category)));
}

function toggleCategorySelection(cat, { exclusive = false } = {}) {
  if (cat == null) return;
  const allCats = getAllCategoryNames();
  if (!allCats.length) return;
  if (!(activeCategories instanceof Set) || activeCategories === null) {
    activeCategories = new Set(allCats);
  }
  let next = new Set(activeCategories);
  if (exclusive) {
    const onlySelected = next.size === 1 && next.has(cat);
    next = onlySelected ? new Set(allCats) : new Set([cat]);
  } else {
    if (next.has(cat)) {
      next.delete(cat);
    } else {
      next.add(cat);
    }
  }
  activeCategories = next;
  render();
}

function applyForceRelaxation(catNodes, xScale, yScale) {
  if (!catNodes.length) return;
  const simNodes = catNodes.map(d => {
    const px = xScale(d.x);
    const py = yScale(d.y);
    const radius = Math.max(10, Math.sqrt(Math.abs(d.size || 0)) * 0.8 + 10);
    return {
      ref: d,
      x: px,
      y: py,
      targetX: px,
      targetY: py,
      radius,
    };
  });

  const simulation = d3.forceSimulation(simNodes)
    .force("x", d3.forceX(n => n.targetX).strength(0.18))
    .force("y", d3.forceY(n => n.targetY).strength(0.18))
    .force("collide", d3.forceCollide(n => n.radius).strength(0.9))
    .stop();

  const iterations = clamp(20 + simNodes.length, 30, 120);
  for (let i = 0; i < iterations; i++) simulation.tick();

  const invX = xScale.invert.bind(xScale);
  const invY = yScale.invert.bind(yScale);
  simNodes.forEach(n => {
    n.ref._layoutX = invX(n.x);
    n.ref._layoutY = invY(n.y);
    n.ref._offsetX = n.x - n.targetX;
    n.ref._offsetY = n.y - n.targetY;
    const baseX = n.ref._layoutX != null ? n.ref._layoutX : n.ref.x;
    const baseY = n.ref._layoutY != null ? n.ref._layoutY : n.ref.y;
    n.ref._baseX = baseX;
    n.ref._baseY = baseY;
    if (n.ref._dispX == null) n.ref._dispX = baseX;
    if (n.ref._dispY == null) n.ref._dispY = baseY;
  });
}

function resolveCatX(d, scale) {
  const domX = d._dispX != null ? d._dispX : (d._layoutX != null ? d._layoutX : d.x);
  return scale(domX);
}

function resolveCatY(d, scale) {
  const domY = d._dispY != null ? d._dispY : (d._layoutY != null ? d._layoutY : d.y);
  return scale(domY);
}

function categoryScreenX(d) {
  return resolveCatX(d, x);
}

function categoryScreenY(d) {
  return resolveCatY(d, y);
}

function sampleScreenX(d) {
  const domX = d._dispX != null ? d._dispX : d.x;
  return x(domX);
}

function sampleScreenY(d) {
  const domY = d._dispY != null ? d._dispY : d.y;
  return y(domY);
}

function edgeOpacity(base, zoomK) {
  const k = clamp(zoomK, 0.7, 3.0);
  const adjust = k <= 1 ? 0.55 + 0.1 * (k - 0.7) / 0.3 : 0.65 + 0.2 * (k - 1);
  return clamp(base * adjust, 0.02, 0.5);
}

function getSampleKey(d) {
  return String(d.id ?? d.ID ?? d.Id ?? "");
}

function buildEdgePath(d) {
  const sx = d._sx;
  const sy = d._sy;
  const tx = d._tx;
  const ty = d._ty;
  const dx = tx - sx;
  const dy = ty - sy;
  const dist = Math.sqrt(dx * dx + dy * dy);
  if (!dist) return `M${sx},${sy}`;
  const norm = 1 / dist;
  const offset = Math.min(42, dist * 0.3);
  const cx = (sx + tx) / 2 - dy * norm * offset * 0.3;
  const cy = (sy + ty) / 2 + dx * norm * offset * 0.3;
  return `M${sx},${sy} Q${cx},${cy} ${tx},${ty}`;
}

function applyFocusPositions(hasSelection, connectedLabels, linkedSamples) {
  const focusLabels = new Set();
  if (hasSelection) {
    focusLabels.add(selectedCategoryLabel);
    for (const lbl of connectedLabels) focusLabels.add(lbl);
  }

  const allCats = categories || [];
  for (const d of allCats) {
    const baseX = d._baseX ?? d._layoutX ?? d.x;
    const baseY = d._baseY ?? d._layoutY ?? d.y;
    d._baseX = baseX;
    d._baseY = baseY;
  }
  const allSamples = samples || [];
  for (const s of allSamples) {
    s._baseX = s.x;
    s._baseY = s.y;
  }

  if (!hasSelection || focusLabels.size === 0) {
    for (const d of allCats) {
      const baseX = d._baseX ?? d.x;
      const baseY = d._baseY ?? d.y;
      d._dispX = baseX;
      d._dispY = baseY;
    }
    for (const s of allSamples) {
      s._dispX = s._baseX ?? s.x;
      s._dispY = s._baseY ?? s.y;
    }
    return;
  }

  const focusCats = allCats.filter(d => focusLabels.has(d.label));
  const centerX = focusCats.length ? d3.mean(focusCats, d => d._baseX ?? d.x) : null;
  const centerY = focusCats.length ? d3.mean(focusCats, d => d._baseY ?? d.y) : null;

  for (const d of allCats) {
    const baseX = d._baseX ?? d.x;
    const baseY = d._baseY ?? d.y;
    if (focusLabels.has(d.label) && centerX != null && centerY != null) {
      d._dispX = baseX + (centerX - baseX) * 0.35;
      d._dispY = baseY + (centerY - baseY) * 0.35;
    } else {
      d._dispX = baseX;
      d._dispY = baseY;
    }
  }

  const focusSampleIds = new Set();
  if (linkedSamples instanceof Set) {
    for (const id of linkedSamples) focusSampleIds.add(id);
  }
  const focusSamples = [];
  focusSampleIds.forEach(id => {
    const sample = sampleById.get(id);
    if (sample) focusSamples.push(sample);
  });
  const sampleCenterX = focusSamples.length ? d3.mean(focusSamples, s => s._baseX ?? s.x) : centerX;
  const sampleCenterY = focusSamples.length ? d3.mean(focusSamples, s => s._baseY ?? s.y) : centerY;

  for (const s of allSamples) {
    const baseX = s._baseX ?? s.x;
    const baseY = s._baseY ?? s.y;
    if (focusSampleIds.has(getSampleKey(s)) && sampleCenterX != null && sampleCenterY != null) {
      s._dispX = baseX + (sampleCenterX - baseX) * 0.45;
      s._dispY = baseY + (sampleCenterY - baseY) * 0.45;
    } else {
      s._dispX = baseX;
      s._dispY = baseY;
    }
  }
}

function updateEdgeGeometry(transition = null) {
  const selection = gPlot.selectAll("path.edge");
  selection.each(function(d) {
    const s = categoryByLabel.get(d._sourceLabel);
    const t = categoryByLabel.get(d._targetLabel);
    if (!s || !t) return;
    d._sx = categoryScreenX(s);
    d._sy = categoryScreenY(s);
    d._tx = categoryScreenX(t);
    d._ty = categoryScreenY(t);
  });
  const target = transition ? selection.transition(transition) : selection;
  target.attr("d", d => buildEdgePath(d));
  return target;
}

function renderSummary() {
  if (!summaryContent.node()) return;
  summaryContent.selectAll("*").remove();
  if (!categories.length) return;

  const filteredCategories = activeCategories instanceof Set
    ? (activeCategories.size === 0
      ? []
      : categories.filter(d => activeCategories.has(d.category)))
    : categories;
  const cats = Array.from(new Set(filteredCategories.map(d => d.category)));
  if (summaryCategoryFilter !== "all" && !cats.includes(summaryCategoryFilter)) {
    summaryCategoryFilter = "all";
  }

  const grouped = d3.group(filteredCategories, d => d.category);

  summaryContent.append("h2").text("単純集計ビュー");
  summaryContent.append("p")
    .attr("class", "summary-total")
    .text(`サンプル数：${samples.length}`);

  const catTabs = summaryContent.append("div").attr("id", "summary-category-tabs");
  const tabData = ["all", ...cats];
  catTabs.selectAll("button.summary-tab")
    .data(tabData)
    .join("button")
      .attr("type", "button")
      .attr("class", d => `summary-tab${summaryCategoryFilter === d ? " active" : ""}`)
      .text(d => d === "all" ? "すべて" : d)
      .on("click", (event, d) => {
        if (summaryCategoryFilter === d) return;
        summaryCategoryFilter = d;
        renderSummary();
      });

  if (!filteredCategories.length) {
    summaryContent.append("p")
      .attr("class", "summary-empty")
      .text("表示中のカテゴリーがありません。凡例でカテゴリーを選択してください。");
    return;
  }

  const sectionsWrap = summaryContent.append("div").attr("class", "summary-sections");
  const catsToRender = summaryCategoryFilter === "all" ? cats : [summaryCategoryFilter];

  catsToRender.forEach(cat => {
    const items = grouped.get(cat);
    if (!items || !items.length) return;
    const section = sectionsWrap.append("section").attr("class", "summary-section");
    section.append("h3")
      .text(cat)
      .style("color", colorScale(cat));
    const sortedItems = items.slice().sort((a, b) => (b.hit_count ?? 0) - (a.hit_count ?? 0));
    const list = section.append("ol");
    list.selectAll("li")
      .data(sortedItems)
      .join("li")
      .text(d => `${d.label}（${d.hit_count ?? 0}）`);
  });
}

function setView(view) {
  const target = view === "summary" ? "summary" : "network";
  currentView = target;
  if (svgNode) svgNode.style.display = target === "network" ? "block" : "none";
  if (summaryViewEl) {
    summaryViewEl.style.display = target === "summary" ? "block" : "none";
    if (target === "summary") summaryViewEl.scrollTop = 0;
  }
  tabButtons.forEach(btn => btn.classList.toggle("active", btn.dataset.view === target));
  if (target === "network") {
    applyHighlights(false);
  }
}

function setSelectedCategory(label) {
  const next = label && String(label);
  selectedCategoryLabel = selectedCategoryLabel === next ? null : next;
  applyHighlights(true);
}

function applyHighlights(animated = false) {
  const hasSelection = !!selectedCategoryLabel;
  const edgesGroup = gPlot.select("g.edges");
  if (!hasSelection) {
    edgesGroup.style("display", "none");
  } else {
    edgesGroup.style("display", "block");
  }
  const linkedSamples = hasSelection ? categorySampleMap.get(selectedCategoryLabel) : null;
  const connectedLabels = new Set();
  if (hasSelection) {
    gPlot.selectAll("path.edge")
      .each(d => {
        if (d._sourceLabel === selectedCategoryLabel) connectedLabels.add(d._targetLabel);
        else if (d._targetLabel === selectedCategoryLabel) connectedLabels.add(d._sourceLabel);
      });
  }
  applyFocusPositions(hasSelection, connectedLabels, linkedSamples);

  const transition = animated ? d3.transition().duration(650).ease(d3.easeCubicOut) : null;

  const edgeSel = updateEdgeGeometry(transition);

  if (!hasSelection) {
    edgeSel.style("display", "none");
  } else {
    edgeSel.style("display", (d) => {
      const isActive = d._sourceLabel === selectedCategoryLabel || d._targetLabel === selectedCategoryLabel;
      return isActive ? "block" : "none";
    });
  }

  const catCircleSelection = transition ? gPlot.selectAll("circle.cat").transition(transition) : gPlot.selectAll("circle.cat");
  catCircleSelection
    .attr("cx", categoryScreenX)
    .attr("cy", categoryScreenY)
    .attr("opacity", d => {
      if (!hasSelection) return 0.2;
      if (d.label === selectedCategoryLabel) return 0.36;
      if (connectedLabels.has(d.label)) return 0.24;
      return 0.08;
    })
    .attr("stroke-width", d => {
      if (!hasSelection) return 0.6;
      if (d.label === selectedCategoryLabel) return 1.4;
      if (connectedLabels.has(d.label)) return 1.0;
      return 0.4;
    });

  const catLabelSelection = transition ? gPlot.selectAll("text.cat-label").transition(transition) : gPlot.selectAll("text.cat-label");
  catLabelSelection
    .attr("x", d => resolveCatX(d, x) + (d._offsetX || 0) * 0.18)
    .attr("y", d => resolveCatY(d, y) + (d._offsetY || 0) * 0.18)
    .attr("opacity", d => {
      if (!hasSelection) return 0.95;
      if (d.label === selectedCategoryLabel) return 1;
      if (connectedLabels.has(d.label)) return 0.75;
      return 0.2;
    });

  const sampleCircleSelection = transition ? gPlot.selectAll("circle.sample").transition(transition) : gPlot.selectAll("circle.sample");
  sampleCircleSelection
    .attr("cx", sampleScreenX)
    .attr("cy", sampleScreenY)
    .attr("opacity", d => {
      if (!hasSelection) return 0.35;
      return linkedSamples && linkedSamples.has(getSampleKey(d)) ? 0.58 : 0.06;
    })
    .attr("fill", d => {
      if (!hasSelection) return "#666";
      return linkedSamples && linkedSamples.has(getSampleKey(d)) ? "#2c2c2c" : "#bfbfbf";
    });

  const sampleLabelSelection = transition ? gPlot.selectAll("text.sample-label").transition(transition) : gPlot.selectAll("text.sample-label");
  sampleLabelSelection
    .attr("x", sampleScreenX)
    .attr("y", sampleScreenY)
    .attr("fill-opacity", d => {
      if (!hasSelection) return 1;
      return linkedSamples && linkedSamples.has(getSampleKey(d)) ? 1 : 0.08;
    });

  edgeSel
    .attr("stroke-opacity", function(d) {
      const baseOpacity = d._opacityBase || 0.015;
      const isActive = hasSelection && (d._sourceLabel === selectedCategoryLabel || d._targetLabel === selectedCategoryLabel);
      return isActive ? clamp(baseOpacity * 7, 0.08, 0.85) : edgeOpacity(baseOpacity, currentK);
    })
    .attr("stroke-width", function(d) {
      const width = d._w || 0.15;
      const isActive = hasSelection && (d._sourceLabel === selectedCategoryLabel || d._targetLabel === selectedCategoryLabel);
      return isActive ? width * 1.8 : width;
    })
    .attr("stroke", function(d) {
      if (!hasSelection) return "#999";
      const isActive = d._sourceLabel === selectedCategoryLabel || d._targetLabel === selectedCategoryLabel;
      if (!isActive) return "#999";
      const cat = (d._sourceLabel === selectedCategoryLabel ? d._sourceCategory : d._targetCategory) || d._sourceCategory;
      return colorScale(cat) || "#666";
    });
}

// 固定ファイル読込関数
async function loadFixed(){
  try{
    const [sRows, cRows, net] = await Promise.all([
      d3.csv("d3_samples.csv", d3.autoType),
      d3.csv("d3_categories.csv", d3.autoType),
      d3.json("network_data.json")
    ]);
    samples = normalizeColumns(sRows);
    categories = normalizeColumns(cRows);
    network = (net && Array.isArray(net.edges)) ? net : {nodes:[], edges:[]};
    activeCategories = new Set(categories.map(d => d.category));
    render();
  } catch(e) {
    console.error("固定ファイル読込エラー", e);
  }
}

function fitToWindow() {
  width = window.innerWidth; height = window.innerHeight;
  svg.attr("width", width).attr("height", height);
}
fitToWindow();
window.addEventListener("resize", () => { fitToWindow(); render(); });

function readFileAsText(file) {
  return new Promise((resolve, reject) => {
    const r = new FileReader();
    r.onload = () => resolve(r.result);
    r.onerror = reject;
    r.readAsText(file, "utf-8");
  });
}

function ingestFile(name, text) {
  const lower = (name || "").toLowerCase();
  if (lower.endsWith(".json")) {
    try {
      const obj = JSON.parse(text);
      if (obj && Array.isArray(obj.nodes) && Array.isArray(obj.edges)) {
        network = obj;
        return "network";
      }
    } catch (e) {}
    return "unknown";
  }
  const rows = d3.csvParse(text, d3.autoType);
  const norm = normalizeColumns(rows);
  const headers = norm.columns.map(String);
  const isCats = headers.includes("category") && headers.includes("x") && headers.includes("y");
  const isSamples = headers.includes("id") && headers.includes("x") && headers.includes("y");
  if (isCats) { categories = norm; activeCategories = new Set(categories.map(d => d.category)); return "categories"; }
  else if (isSamples) { samples = norm; return "samples"; }
  return "unknown";
}

async function handleFilesInput(inputEl) {
  const file = inputEl.files[0];
  if (!file) return;
  const text = await readFileAsText(file);
  ingestFile(file.name, text);
  render();
}
// Drag & drop は無効化（固定ファイル読込に変更）
// window.addEventListener("dragover", (e) => e.preventDefault());
// window.addEventListener("drop", async (e) => { /* disabled */ });

// 入力UIは使わず固定ロードに変更
// document.getElementById("samplesFile").addEventListener("change", (e) => handleFilesInput(e.target));
// document.getElementById("catsFile").addEventListener("change", (e) => handleFilesInput(e.target));
// document.getElementById("netFile").addEventListener("change", (e) => handleFilesInput(e.target));
// Removed search input event listener as per instructions
// document.getElementById("search").addEventListener("input", (e) => { searchText = (e.target.value || "").trim(); render(); });

// Removed scaleResp and scaleRespVal event listener and references
// const scaleResp = document.getElementById("scaleResp");
// const scaleRespVal = document.getElementById("scaleRespVal");
// scaleResp.addEventListener("input", (e) => { sizeResponse = +e.target.value; scaleRespVal.textContent = (+sizeResponse).toFixed(2); updateSizes(currentK); });

function updateSizes(k) {
  // 円・エッジはズームにそのまま追従（補正しない）
  gPlot.selectAll("circle.sample")
    .attr("r", d => (d._r || 3));

  gPlot.selectAll("circle.cat")
    .attr("r", d => (d._r || 6));

  gPlot.selectAll("path.edge")
    .attr("stroke-width", d => (d._w || 0.15))
    .attr("stroke-opacity", d => edgeOpacity(d._opacityBase || 0.015, k));

  // テキストは見かけサイズをほぼ一定に（ズームしても極端に小さくならないよう補正）
  const denom = Math.pow(k, 0.6); // 小さめのスケーリング補正（完全固定より自然）
  gPlot.selectAll("text.sample-label").attr("font-size", 12 / denom);
  gPlot.selectAll("text.cat-label").attr("font-size", 10 / denom);
}

function render() {
  if (!categories.length && !samples.length) return;
  const all = samples.concat(categories);
  const xExtent = d3.extent(all, d => d.x);
  const yExtent = d3.extent(all, d => d.y);
  x = d3.scaleLinear().domain(xExtent).nice().range([MARGIN.left, width - MARGIN.right]);
  y = d3.scaleLinear().domain(yExtent).nice().range([height - MARGIN.bottom, MARGIN.top]);
  const cats = Array.from(new Set(categories.map(d => d.category)));
  if (!(activeCategories instanceof Set) || activeCategories === null) {
    activeCategories = new Set(cats);
  } else {
    const availableCats = new Set(cats);
    const nextActive = new Set();
    activeCategories.forEach(cat => {
      if (availableCats.has(cat)) nextActive.add(cat);
    });
    activeCategories = nextActive;
  }
  colorScale = d3.scaleOrdinal().domain(cats).range(d3.schemeTableau10);
  const hitExtent = d3.extent(categories, d => (d.hit_count ?? 0));
  rScale = d3.scaleSqrt().domain(hitExtent).range([4, 26]);
  const edgeExtent = d3.extent((network.edges || []).map(e => +e.totalCount || 0));
  edgeWidthScale = d3.scaleSqrt().domain(edgeExtent[0] == null ? [0,1] : edgeExtent).range([0.15, 0.8]);

  if (categoryToggleRow) {
    const toggleButtons = d3.select(categoryToggleRow)
      .selectAll("button.category-toggle")
      .data(cats, d => d)
      .join(
        enter => {
          const btn = enter.append("button")
            .attr("type", "button")
            .attr("class", "category-toggle");
          btn.append("span").attr("class", "swatch");
          btn.append("span").attr("class", "label");
          return btn;
        },
        update => update,
        exit => exit.remove()
      );
    toggleButtons
      .classed("inactive", d => activeCategories instanceof Set && (activeCategories.size === 0 || !activeCategories.has(d)))
      .on("click", (event, cat) => {
        event.stopPropagation();
        const exclusive = event.metaKey || event.ctrlKey || event.shiftKey;
        toggleCategorySelection(cat, { exclusive });
      });
    toggleButtons.select("span.swatch")
      .style("background", d => colorScale(d) || "#333");
    toggleButtons.select("span.label")
      .text(d => d);
  }

  // const searchLower = searchText.toLowerCase(); // removed as per instructions
  const catsFiltered = categories.filter(d => {
    if (!(activeCategories instanceof Set)) return true;
    if (activeCategories.size === 0) return false;
    return activeCategories.has(d.category);
  });

  gPlot.selectAll("*").remove();
  const gEdgesLocal = gPlot.append("g").attr("class", "edges").style("display", "none");
  const gSamples = gPlot.append("g").attr("class", "samples");
  const gCats = gPlot.append("g").attr("class", "categories");

  const catByLabel = new Map();
  for (const d of catsFiltered) catByLabel.set(String(d.label), d);

  applyForceRelaxation(catsFiltered, x, y);
  for (const d of catsFiltered) {
    const baseX = d._baseX ?? d._layoutX ?? d.x;
    const baseY = d._baseY ?? d._layoutY ?? d.y;
    d._baseX = baseX;
    d._baseY = baseY;
    d._dispX = baseX;
    d._dispY = baseY;
  }
  categoryByLabel = new Map(catByLabel);

  sampleById = new Map();
  for (const s of samples) {
    const key = getSampleKey(s);
    if (key) sampleById.set(key, s);
    s._baseX = s.x;
    s._baseY = s.y;
    if (s._dispX == null) s._dispX = s.x;
    if (s._dispY == null) s._dispY = s.y;
  }

  categorySampleMap = new Map();
  if (Array.isArray(network.sampleLinks)) {
    for (const link of network.sampleLinks) {
      const label = String(link.label);
      if (!catByLabel.has(label)) continue;
      const bucket = categorySampleMap.get(label) || new Set();
      bucket.add(String(link.sampleId));
      categorySampleMap.set(label, bucket);
    }
  }
  if (selectedCategoryLabel && !categorySampleMap.has(selectedCategoryLabel)) {
    selectedCategoryLabel = null;
  }

  const baseEdgeOpacity = 0.015;
  const edgeData = (network.edges || []).filter(e => catByLabel.has(String(e.source)) && catByLabel.has(String(e.target)));
  gEdgesLocal.selectAll("path.edge")
    .data(edgeData)
    .join("path")
      .attr("class", "edge")
      .each(d => {
        const s = catByLabel.get(String(d.source));
        const t = catByLabel.get(String(d.target));
        d._sourceLabel = s.label;
        d._targetLabel = t.label;
        d._sourceCategory = s.category;
        d._targetCategory = t.category;
        d._sx = resolveCatX(s, x);
        d._sy = resolveCatY(s, y);
        d._tx = resolveCatX(t, x);
        d._ty = resolveCatY(t, y);
        d._w = Math.max(0.1, edgeWidthScale(+d.totalCount || 0));
        d._opacityBase = baseEdgeOpacity;
      })
      .attr("d", d => buildEdgePath(d))
      .attr("stroke", "#999")
      .attr("stroke-opacity", baseEdgeOpacity)
      .attr("stroke-width", d => d._w)
      .attr("fill", "none");

  gSamples.selectAll("circle.sample")
    .data(samples)
    .join("circle")
      .attr("class", "sample")
      .attr("cx", sampleScreenX)
      .attr("cy", sampleScreenY)
      .each(d => d._r = 3)
      .attr("r", d => d._r)
      .attr("fill", "#666")
      .attr("opacity", 0.35) // より薄く
      .attr("stroke", "none"); // ストロークを消去

  // gSamples.selectAll("text.sample-label")
  //   .data(samples)
  //   .join("text")
  //     .attr("class", "sample-label")
  //     .attr("x", d => x(d.x))
  //     .attr("y", d => y(d.y))
  //     .attr("text-anchor", "middle")
  //     .attr("dominant-baseline", "central")
  //     .attr("font-size", 8)
  //     .attr("fill", d => (d.category ? colorScale(d.category) : "#444"))
  //     .text(d => formatSampleId(d.id ?? d.ID ?? d.Id));

  gSamples.selectAll("a.sample-link")
    .data(samples)
    .join("a")
      .attr("class", "sample-link")
      .attr("xlink:href", d => `https://dfchanges.site/100stories/${formatSampleId(d.id ?? d.ID ?? d.Id)}`)
      .attr("target", "_blank")
      .on("click", (event) => event.stopPropagation())
    .append("text")
      .attr("class", "sample-label")
      .attr("x", sampleScreenX)
      .attr("y", sampleScreenY)
      .attr("text-anchor", "middle")
      .attr("dominant-baseline", "central")
      .attr("font-size", 12)
      .attr("fill", d => (d.category ? colorScale(d.category) : "#444"))
      .text(d => formatSampleId(d.id ?? d.ID ?? d.Id));

  gCats.selectAll("circle.cat")
    .data(catsFiltered)
    .join("circle")
      .attr("class", "cat")
      .attr("cx", d => resolveCatX(d, x))
      .attr("cy", d => resolveCatY(d, y))
      .each(d => d._r = (d.size != null ? Math.max(2, Math.sqrt(d.size)) : rScale(d.hit_count ?? 0)))
      .attr("r", d => d._r)
      .attr("fill", d => colorScale(d.category))
      .attr("stroke", d => colorScale(d.category))
      .attr("opacity", 0.2)
      .attr("stroke-width", 0.6)
      .style("cursor", "pointer")
      .on("click", (event, d) => {
        event.stopPropagation();
        setSelectedCategory(d.label);
      });

  gCats.selectAll("text.cat-label")
    .data(catsFiltered)
    .join("text")
      .attr("class", "cat-label")
      .attr("x", d => resolveCatX(d, x) + (d._offsetX || 0) * 0.18)
      .attr("y", d => resolveCatY(d, y) + (d._offsetY || 0) * 0.18)
      .attr("text-anchor", "middle")
      .attr("dominant-baseline", "central")
      .attr("font-size", 12)
      .attr("fill", d => colorScale(d.category))
      .attr("opacity", 0.95)
      .text(d => d.label ?? "")
      .style("pointer-events", "auto")
      .style("cursor", "pointer")
      .on("click", (event, d) => {
        event.stopPropagation();
        setSelectedCategory(d.label);
      });

  renderSummary();
  updateSizes(currentK);
  applyHighlights(false);
}
</script>
<script>
// ページ読み込み時に固定ファイルを読み込む
setView("network");
loadFixed();
</script>
