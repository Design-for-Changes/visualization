<!doctype html>
<meta charset="utf-8" />
<style>
  html, body { height: 100%; margin: 0; }
  body { font-family: -apple-system, "Hiragino Sans", "Noto Sans CJK JP", sans-serif; }
  #controls {
    position: fixed;
    top: 10px; left: 12px;
    display: flex; gap: 8px; align-items: center;
    background: rgba(255,255,255,0.9);
    border: 1px solid #ddd; border-radius: 6px;
    padding: 6px 10px; z-index: 10;
    box-shadow: 0 2px 8px rgba(0,0,0,0.06);
    backdrop-filter: blur(2px);
  }
  #controls input[type="file"] { max-width: 220px; }
  #controls input[type="text"] {
    padding: 4px 8px; border: 1px solid #ccc; border-radius: 4px;
  }
  #controls button {
    padding: 4px 8px; border: 1px solid #ccc; border-radius: 4px;
    background: #f6f6f6; cursor: pointer;
  }
  #controls button:hover { background: #eee; }
  #hint {
    position: fixed; right: 12px; top: 10px; z-index: 10;
    font-size: 12px; color: #555; background: rgba(255,255,255,0.85);
    padding: 6px 10px; border-radius: 6px; border: 1px solid #ddd;
  }
  svg { width: 100vw; height: 100vh; display: block; background: #fff; }
  .legend-root { pointer-events: none; }
  .legend-item { pointer-events: all; cursor: pointer; }
  .legend-item.inactive { opacity: 0.35; text-decoration: line-through; }
</style>

<svg id="chart"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script>
const svg = d3.select("#chart");
const MARGIN = { top: 60, right: 10, bottom: 10, left: 10 };
let width = window.innerWidth, height = window.innerHeight;

const gPlot = svg.append("g").attr("class", "plot");
const gLegend = svg.append("g").attr("class", "legend-root");
const gEdges = gPlot.append("g").attr("class", "edges");

const tooltip = d3.select("body").append("div")
  .style("position", "absolute")
  .style("padding", "6px 10px")
  .style("background", "rgba(0,0,0,0.75)")
  .style("color", "white")
  .style("border-radius", "4px")
  .style("font-size", "12px")
  .style("pointer-events", "none")
  .style("opacity", 0);

let samples = [];
let categories = [];
let network = { nodes: [], edges: [] };
let activeCategories = new Set();
// let searchText = ""; // removed as per instructions

let x = d3.scaleLinear(), y = d3.scaleLinear();
let colorScale = d3.scaleOrdinal();
let rScale = d3.scaleSqrt();
let currentK = 1;
const sizeResponse = 1.0; // fixed value
let edgeWidthScale = d3.scaleSqrt();
let edgeOpacityScale = d3.scaleSqrt();
let selectedCategoryLabel = null;
let categorySampleMap = new Map();

const zoom = d3.zoom()
  .scaleExtent([0.5, 12])
  .on("zoom", (event) => {
    currentK = event.transform.k;
    gPlot.attr("transform", event.transform);
    updateSizes(currentK);
    applyHighlights();
  });
svg.call(zoom);
svg.on("click.highlight", () => {
  setSelectedCategory(null);
});

function formatSampleId(v) {
  const n = +v;
  if (Number.isFinite(n)) {
    const adj = (n >= 1000 ? n - 1000 : n);
    return String(Math.max(0, Math.trunc(adj))).padStart(3, "0");
  }
  return v ?? "(idなし)";
}
function normalizeColumns(rows) {
  const trimmed = rows.map(r => {
    const o = {};
    for (const k of rows.columns) {
      const key = String(k).trim();
      o[key] = r[k];
    }
    return o;
  });
  trimmed.columns = rows.columns.map(c => String(c).trim());
  return trimmed;
}

function clamp(value, min, max) {
  return Math.min(max, Math.max(min, value));
}

function applyForceRelaxation(catNodes, xScale, yScale) {
  if (!catNodes.length) return;
  const simNodes = catNodes.map(d => {
    const px = xScale(d.x);
    const py = yScale(d.y);
    const radius = Math.max(10, Math.sqrt(Math.abs(d.size || 0)) * 0.8 + 10);
    return {
      ref: d,
      x: px,
      y: py,
      targetX: px,
      targetY: py,
      radius,
    };
  });

  const simulation = d3.forceSimulation(simNodes)
    .force("x", d3.forceX(n => n.targetX).strength(0.18))
    .force("y", d3.forceY(n => n.targetY).strength(0.18))
    .force("collide", d3.forceCollide(n => n.radius).strength(0.9))
    .stop();

  const iterations = clamp(20 + simNodes.length, 30, 120);
  for (let i = 0; i < iterations; i++) simulation.tick();

  const invX = xScale.invert.bind(xScale);
  const invY = yScale.invert.bind(yScale);
  simNodes.forEach(n => {
    n.ref._layoutX = invX(n.x);
    n.ref._layoutY = invY(n.y);
    n.ref._offsetX = n.x - n.targetX;
    n.ref._offsetY = n.y - n.targetY;
  });
}

function resolveCatX(d, scale) {
  return scale(d._layoutX != null ? d._layoutX : d.x);
}

function resolveCatY(d, scale) {
  return scale(d._layoutY != null ? d._layoutY : d.y);
}

function edgeOpacity(base, zoomK) {
  const k = clamp(zoomK, 0.7, 3.0);
  const adjust = k <= 1 ? 0.55 + 0.1 * (k - 0.7) / 0.3 : 0.65 + 0.2 * (k - 1);
  return clamp(base * adjust, 0.02, 0.5);
}

function getSampleKey(d) {
  return String(d.id ?? d.ID ?? d.Id ?? "");
}

function buildEdgePath(d) {
  const sx = d._sx;
  const sy = d._sy;
  const tx = d._tx;
  const ty = d._ty;
  const dx = tx - sx;
  const dy = ty - sy;
  const dist = Math.sqrt(dx * dx + dy * dy);
  if (!dist) return `M${sx},${sy}`;
  const norm = 1 / dist;
  const offset = Math.min(42, dist * 0.3);
  const cx = (sx + tx) / 2 - dy * norm * offset * 0.3;
  const cy = (sy + ty) / 2 + dx * norm * offset * 0.3;
  return `M${sx},${sy} Q${cx},${cy} ${tx},${ty}`;
}

function setSelectedCategory(label) {
  const next = label && String(label);
  selectedCategoryLabel = selectedCategoryLabel === next ? null : next;
  applyHighlights();
}

function applyHighlights() {
  const hasSelection = !!selectedCategoryLabel;
  const linkedSamples = hasSelection ? categorySampleMap.get(selectedCategoryLabel) : null;
  const connectedLabels = new Set();
  if (hasSelection) {
    gPlot.selectAll("path.edge")
      .each(d => {
        if (d._sourceLabel === selectedCategoryLabel) connectedLabels.add(d._targetLabel);
        else if (d._targetLabel === selectedCategoryLabel) connectedLabels.add(d._sourceLabel);
      });
  }
  gPlot.selectAll("path.edge")
    .each(function(d) {
      const isActive = hasSelection && (d._sourceLabel === selectedCategoryLabel || d._targetLabel === selectedCategoryLabel);
      const baseOpacity = d._opacityBase || 0.015;
      const width = d._w || 0.15;
      let strokeColor = "#999";
      if (isActive) {
        const cat = (d._sourceLabel === selectedCategoryLabel ? d._sourceCategory : d._targetCategory) || d._sourceCategory;
        strokeColor = colorScale(cat) || "#666";
      }
      d3.select(this)
        .attr("stroke-opacity", isActive ? clamp(baseOpacity * 7, 0.08, 0.85) : edgeOpacity(baseOpacity, currentK))
        .attr("stroke-width", isActive ? width * 1.8 : width)
        .attr("stroke", strokeColor);
    });

  gPlot.selectAll("circle.cat")
    .attr("opacity", d => {
      if (!hasSelection) return 0.2;
      if (d.label === selectedCategoryLabel) return 0.36;
      if (connectedLabels.has(d.label)) return 0.24;
      return 0.08;
    })
    .attr("stroke-width", d => {
      if (!hasSelection) return 0.6;
      if (d.label === selectedCategoryLabel) return 1.4;
      if (connectedLabels.has(d.label)) return 1.0;
      return 0.4;
    });

  gPlot.selectAll("text.cat-label")
    .attr("opacity", d => {
      if (!hasSelection) return 0.95;
      if (d.label === selectedCategoryLabel) return 1;
      if (connectedLabels.has(d.label)) return 0.75;
      return 0.2;
    });

  gPlot.selectAll("circle.sample")
    .attr("opacity", d => {
      if (!hasSelection) return 0.35;
      return linkedSamples && linkedSamples.has(getSampleKey(d)) ? 0.58 : 0.06;
    })
    .attr("fill", d => {
      if (!hasSelection) return "#666";
      return linkedSamples && linkedSamples.has(getSampleKey(d)) ? "#2c2c2c" : "#bfbfbf";
    });

  gPlot.selectAll("text.sample-label")
    .attr("fill-opacity", d => {
      if (!hasSelection) return 1;
      return linkedSamples && linkedSamples.has(getSampleKey(d)) ? 1 : 0.08;
    });
}

// 固定ファイル読込関数
async function loadFixed(){
  try{
    const [sRows, cRows, net] = await Promise.all([
      d3.csv("d3_samples.csv", d3.autoType),
      d3.csv("d3_categories.csv", d3.autoType),
      d3.json("network_data.json")
    ]);
    samples = normalizeColumns(sRows);
    categories = normalizeColumns(cRows);
    network = (net && Array.isArray(net.edges)) ? net : {nodes:[], edges:[]};
    activeCategories = new Set(categories.map(d => d.category));
    render();
  } catch(e) {
    console.error("固定ファイル読込エラー", e);
  }
}

function fitToWindow() {
  width = window.innerWidth; height = window.innerHeight;
  svg.attr("width", width).attr("height", height);
  gLegend.attr("transform", `translate(${width - MARGIN.right - 200}, ${MARGIN.top})`);
}
fitToWindow();
window.addEventListener("resize", () => { fitToWindow(); render(); });

function readFileAsText(file) {
  return new Promise((resolve, reject) => {
    const r = new FileReader();
    r.onload = () => resolve(r.result);
    r.onerror = reject;
    r.readAsText(file, "utf-8");
  });
}

function ingestFile(name, text) {
  const lower = (name || "").toLowerCase();
  if (lower.endsWith(".json")) {
    try {
      const obj = JSON.parse(text);
      if (obj && Array.isArray(obj.nodes) && Array.isArray(obj.edges)) {
        network = obj;
        return "network";
      }
    } catch (e) {}
    return "unknown";
  }
  const rows = d3.csvParse(text, d3.autoType);
  const norm = normalizeColumns(rows);
  const headers = norm.columns.map(String);
  const isCats = headers.includes("category") && headers.includes("x") && headers.includes("y");
  const isSamples = headers.includes("id") && headers.includes("x") && headers.includes("y");
  if (isCats) { categories = norm; activeCategories = new Set(categories.map(d => d.category)); return "categories"; }
  else if (isSamples) { samples = norm; return "samples"; }
  return "unknown";
}

async function handleFilesInput(inputEl) {
  const file = inputEl.files[0];
  if (!file) return;
  const text = await readFileAsText(file);
  ingestFile(file.name, text);
  render();
}
// Drag & drop は無効化（固定ファイル読込に変更）
// window.addEventListener("dragover", (e) => e.preventDefault());
// window.addEventListener("drop", async (e) => { /* disabled */ });

// 入力UIは使わず固定ロードに変更
// document.getElementById("samplesFile").addEventListener("change", (e) => handleFilesInput(e.target));
// document.getElementById("catsFile").addEventListener("change", (e) => handleFilesInput(e.target));
// document.getElementById("netFile").addEventListener("change", (e) => handleFilesInput(e.target));
// Removed search input event listener as per instructions
// document.getElementById("search").addEventListener("input", (e) => { searchText = (e.target.value || "").trim(); render(); });

// Removed scaleResp and scaleRespVal event listener and references
// const scaleResp = document.getElementById("scaleResp");
// const scaleRespVal = document.getElementById("scaleRespVal");
// scaleResp.addEventListener("input", (e) => { sizeResponse = +e.target.value; scaleRespVal.textContent = (+sizeResponse).toFixed(2); updateSizes(currentK); });

function updateSizes(k) {
  // 円・エッジはズームにそのまま追従（補正しない）
  gPlot.selectAll("circle.sample")
    .attr("r", d => (d._r || 3));

  gPlot.selectAll("circle.cat")
    .attr("r", d => (d._r || 6));

  gPlot.selectAll("path.edge")
    .attr("stroke-width", d => (d._w || 0.15))
    .attr("stroke-opacity", d => edgeOpacity(d._opacityBase || 0.015, k));

  // テキストは見かけサイズをほぼ一定に（ズームしても極端に小さくならないよう補正）
  const denom = Math.pow(k, 0.6); // 小さめのスケーリング補正（完全固定より自然）
  gPlot.selectAll("text.sample-label").attr("font-size", 12 / denom);
  gPlot.selectAll("text.cat-label").attr("font-size", 10 / denom);
}

function render() {
  if (!categories.length && !samples.length) return;
  const all = samples.concat(categories);
  const xExtent = d3.extent(all, d => d.x);
  const yExtent = d3.extent(all, d => d.y);
  x = d3.scaleLinear().domain(xExtent).nice().range([MARGIN.left, width - MARGIN.right]);
  y = d3.scaleLinear().domain(yExtent).nice().range([height - MARGIN.bottom, MARGIN.top]);
  const cats = Array.from(new Set(categories.map(d => d.category)));
  colorScale = d3.scaleOrdinal().domain(cats).range(d3.schemeTableau10);
  const hitExtent = d3.extent(categories, d => (d.hit_count ?? 0));
  rScale = d3.scaleSqrt().domain(hitExtent).range([4, 26]);
  const edgeExtent = d3.extent((network.edges || []).map(e => +e.totalCount || 0));
  edgeWidthScale = d3.scaleSqrt().domain(edgeExtent[0] == null ? [0,1] : edgeExtent).range([0.15, 0.8]);

  // 凡例を描画
  gLegend.selectAll("*").remove();
  const legendItem = gLegend.selectAll("g.legend-item")
    .data(cats)
    .join(enter => {
      const g = enter.append("g")
        .attr("class", "legend-item")
        .attr("transform", (d, i) => `translate(0, ${i * 26})`);
      g.append("text")
        .attr("x", 0)
        .attr("y", 0)
        .attr("alignment-baseline", "middle")
        .attr("font-size", 15)
        .attr("fill", d => colorScale(d) || "#333")
        .text(d => d);
      return g;
    });

  // const searchLower = searchText.toLowerCase(); // removed as per instructions
  const catsFiltered = categories.filter(d => {
    const catOK = activeCategories.size ? activeCategories.has(d.category) : true;
    // const textOK = !searchLower ? true : String(d.label || "").toLowerCase().includes(searchLower); // removed
    // return catOK && textOK;
    return catOK;
  });

  gPlot.selectAll("*").remove();
  const gEdgesLocal = gPlot.append("g").attr("class", "edges");
  const gSamples = gPlot.append("g").attr("class", "samples");
  const gCats = gPlot.append("g").attr("class", "categories");

  const catByLabel = new Map();
  for (const d of catsFiltered) catByLabel.set(String(d.label), d);

  applyForceRelaxation(catsFiltered, x, y);

  categorySampleMap = new Map();
  if (Array.isArray(network.sampleLinks)) {
    for (const link of network.sampleLinks) {
      const label = String(link.label);
      if (!catByLabel.has(label)) continue;
      const bucket = categorySampleMap.get(label) || new Set();
      bucket.add(String(link.sampleId));
      categorySampleMap.set(label, bucket);
    }
  }
  if (selectedCategoryLabel && !categorySampleMap.has(selectedCategoryLabel)) {
    selectedCategoryLabel = null;
  }

  const baseEdgeOpacity = 0.015;
  const edgeData = (network.edges || []).filter(e => catByLabel.has(String(e.source)) && catByLabel.has(String(e.target)));
  gEdgesLocal.selectAll("path.edge")
    .data(edgeData)
    .join("path")
      .attr("class", "edge")
      .each(d => {
        const s = catByLabel.get(String(d.source));
        const t = catByLabel.get(String(d.target));
        d._sourceLabel = s.label;
        d._targetLabel = t.label;
        d._sourceCategory = s.category;
        d._targetCategory = t.category;
        d._sx = resolveCatX(s, x);
        d._sy = resolveCatY(s, y);
        d._tx = resolveCatX(t, x);
        d._ty = resolveCatY(t, y);
        d._w = Math.max(0.1, edgeWidthScale(+d.totalCount || 0));
        d._opacityBase = baseEdgeOpacity;
      })
      .attr("d", d => buildEdgePath(d))
      .attr("stroke", "#999")
      .attr("stroke-opacity", baseEdgeOpacity)
      .attr("stroke-width", d => d._w)
      .attr("fill", "none");

  gSamples.selectAll("circle.sample")
    .data(samples)
    .join("circle")
      .attr("class", "sample")
      .attr("cx", d => x(d.x))
      .attr("cy", d => y(d.y))
      .each(d => d._r = 3)
      .attr("r", d => d._r)
      .attr("fill", "#666")
      .attr("opacity", 0.35) // より薄く
      .attr("stroke", "none"); // ストロークを消去

  // gSamples.selectAll("text.sample-label")
  //   .data(samples)
  //   .join("text")
  //     .attr("class", "sample-label")
  //     .attr("x", d => x(d.x))
  //     .attr("y", d => y(d.y))
  //     .attr("text-anchor", "middle")
  //     .attr("dominant-baseline", "central")
  //     .attr("font-size", 8)
  //     .attr("fill", d => (d.category ? colorScale(d.category) : "#444"))
  //     .text(d => formatSampleId(d.id ?? d.ID ?? d.Id));

  gSamples.selectAll("a.sample-link")
    .data(samples)
    .join("a")
      .attr("class", "sample-link")
      .attr("xlink:href", d => `https://dfchanges.site/100stories/${formatSampleId(d.id ?? d.ID ?? d.Id)}`)
      .attr("target", "_blank")
      .on("click", (event) => event.stopPropagation())
    .append("text")
      .attr("class", "sample-label")
      .attr("x", d => x(d.x))
      .attr("y", d => y(d.y))
      .attr("text-anchor", "middle")
      .attr("dominant-baseline", "central")
      .attr("font-size", 12)
      .attr("fill", d => (d.category ? colorScale(d.category) : "#444"))
      .text(d => formatSampleId(d.id ?? d.ID ?? d.Id));

  gCats.selectAll("circle.cat")
    .data(catsFiltered)
    .join("circle")
      .attr("class", "cat")
      .attr("cx", d => resolveCatX(d, x))
      .attr("cy", d => resolveCatY(d, y))
      .each(d => d._r = (d.size != null ? Math.max(2, Math.sqrt(d.size)) : rScale(d.hit_count ?? 0)))
      .attr("r", d => d._r)
      .attr("fill", d => colorScale(d.category))
      .attr("stroke", d => colorScale(d.category))
      .attr("opacity", 0.2)
      .attr("stroke-width", 0.6)
      .style("cursor", "pointer")
      .on("click", (event, d) => {
        event.stopPropagation();
        setSelectedCategory(d.label);
      });

  gCats.selectAll("text.cat-label")
    .data(catsFiltered)
    .join("text")
      .attr("class", "cat-label")
      .attr("x", d => resolveCatX(d, x) + (d._offsetX || 0) * 0.18)
      .attr("y", d => resolveCatY(d, y) + (d._offsetY || 0) * 0.18)
      .attr("text-anchor", "middle")
      .attr("dominant-baseline", "central")
      .attr("font-size", 12)
      .attr("fill", d => colorScale(d.category))
      .attr("opacity", 0.95)
      .text(d => d.label ?? "")
      .style("pointer-events", "auto")
      .style("cursor", "pointer")
      .on("click", (event, d) => {
        event.stopPropagation();
        setSelectedCategory(d.label);
      });

  updateSizes(currentK);
  applyHighlights();
}
</script>
<script>
// ページ読み込み時に固定ファイルを読み込む
loadFixed();
</script>
